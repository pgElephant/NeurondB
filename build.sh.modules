#!/usr/bin/env bash
#-------------------------------------------------------------------------
# build.sh.modules
#     Modular helper functions for build.sh
#     Provides clean, reusable functions for GPU detection and configuration
#
# Copyright (c) 2024-2025, pgElephant, Inc.
#-------------------------------------------------------------------------

###############################################################################
# GPU BACKEND MODULES
###############################################################################

# Module: CUDA Detection and Configuration
gpu_module_cuda() {
	local cuda_path="${1:-}"
	local detected=false
	
	msg_verbose "CUDA Module: Checking availability..."
	
	# Method 1: User-specified path
	if [[ -n "$cuda_path" ]] && [[ -f "$cuda_path/include/cuda_runtime.h" ]]; then
		CUDA_PATH="$cuda_path"
		detected=true
		msg "CUDA found at: $CUDA_PATH"
	
	# Method 2: nvcc in PATH
	elif has_cmd nvcc; then
		local nvcc_path
		nvcc_path="$(command -v nvcc)"
		cuda_path="$(dirname "$(dirname "$nvcc_path")")"
		
		if [[ -f "$cuda_path/include/cuda_runtime.h" ]]; then
			CUDA_PATH="$cuda_path"
			detected=true
			msg "CUDA found via nvcc: $CUDA_PATH"
		fi
	
	# Method 3: Common installation paths
	else
		local candidates=(
			"${CUDA_HOME:-}"
			"/usr/local/cuda"
			"/usr/local/cuda-12.0"
			"/usr/local/cuda-11.8"
			"/opt/cuda"
			"/usr/lib/cuda"
		)
		
		for candidate in "${candidates[@]}"; do
			[[ -z "$candidate" ]] && continue
			
			if [[ -f "$candidate/include/cuda_runtime.h" ]]; then
				CUDA_PATH="$candidate"
				detected=true
				msg "CUDA found at: $CUDA_PATH"
				break
			fi
		done
	fi
	
	if [[ "$detected" == "true" ]]; then
		# Verify CUDA version
		if has_cmd nvcc; then
			local cuda_ver
			cuda_ver=$(nvcc --version 2>/dev/null | grep "release" | sed 's/.*release \([0-9.]*\).*/\1/' | head -n1 || echo "unknown")
			msg "CUDA version: $cuda_ver"
		fi
		
		# Check for NVIDIA driver
		if has_cmd nvidia-smi; then
			local driver_ver
			set +e
			driver_ver=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -n1 | tr -d ' ')
			set -e
			if [[ -n "$driver_ver" ]] && [[ "$driver_ver" != *"failed"* ]]; then
				msg "NVIDIA driver version: $driver_ver"
			fi
		fi
		
		return 0
	else
		msg_verbose "CUDA not detected"
		return 1
	fi
}

# Module: ROCm Detection and Configuration
gpu_module_rocm() {
	local rocm_path="${1:-}"
	local detected=false
	
	msg_verbose "ROCm Module: Checking availability..."
	
	# Method 1: User-specified path
	if [[ -n "$rocm_path" ]] && [[ -f "$rocm_path/include/hip/hip_runtime.h" ]]; then
		ROCM_PATH="$rocm_path"
		detected=true
		msg "ROCm found at: $ROCM_PATH"
	
	# Method 2: hipcc in PATH
	elif has_cmd hipcc; then
		local hipcc_path
		hipcc_path="$(command -v hipcc)"
		rocm_path="$(dirname "$(dirname "$hipcc_path")")"
		
		if [[ -f "$rocm_path/include/hip/hip_runtime.h" ]]; then
			ROCM_PATH="$rocm_path"
			detected=true
			msg "ROCm found via hipcc: $ROCM_PATH"
		fi
	
	# Method 3: Common installation paths
	else
		local candidates=(
			"${ROCM_HOME:-}"
			"/opt/rocm"
			"/opt/rocm-5.7"
			"/opt/rocm-6.0"
			"/usr/rocm"
		)
		
		for candidate in "${candidates[@]}"; do
			[[ -z "$candidate" ]] && continue
			
			if [[ -f "$candidate/include/hip/hip_runtime.h" ]]; then
				ROCM_PATH="$candidate"
				detected=true
				msg "ROCm found at: $ROCM_PATH"
				
				# Try to read version
				if [[ -f "$candidate/.info/version" ]]; then
					local rocm_ver
					rocm_ver=$(cat "$candidate/.info/version" 2>/dev/null || echo "unknown")
					msg "ROCm version: $rocm_ver"
				fi
				break
			fi
		done
	fi
	
	if [[ "$detected" == "true" ]]; then
		return 0
	else
		msg_verbose "ROCm not detected"
		return 1
	fi
}

# Module: Metal Detection and Configuration
gpu_module_metal() {
	local detected=false
	
	msg_verbose "Metal Module: Checking availability..."
	
	# Metal is only available on macOS
	if [[ "$PLATFORM" != "osx" ]]; then
		msg_verbose "Metal only available on macOS"
		return 1
	fi
	
	# Check for Xcode Command Line Tools
	if xcode-select -p >/dev/null 2>&1; then
		local xcode_clt
		xcode_clt="$(xcode-select -p 2>/dev/null)"
		msg "Found Xcode Command Line Tools: $xcode_clt"
		
		# Check for Metal framework
		if [[ -d "/System/Library/Frameworks/Metal.framework" ]]; then
			detected=true
			msg "Metal framework available"
		fi
	fi
	
	if [[ "$detected" == "true" ]]; then
		return 0
	else
		msg_verbose "Metal not available (Xcode CLT required)"
		return 1
	fi
}

# Module: GPU Backend Selection and Configuration
gpu_module_select() {
	local requested_mode="${1:-auto}"
	local available_backends=()
	local selected_backends=()
	
	msg_verbose "GPU Selection Module: Processing request '$requested_mode'"
	
	# Detect available backends
	if gpu_module_cuda "$CUDA_PATH"; then
		available_backends+=("cuda")
	fi
	
	if gpu_module_rocm "$ROCM_PATH"; then
		available_backends+=("rocm")
	fi
	
	if gpu_module_metal; then
		available_backends+=("metal")
	fi
	
	# Process request
	if [[ "$requested_mode" == "auto" ]]; then
		# Auto-select: prefer CUDA > ROCm > Metal
		for backend in cuda rocm metal; do
			if [[ " ${available_backends[*]} " =~ " $backend " ]]; then
				selected_backends=("$backend")
				break
			fi
		done
		
		if [[ ${#selected_backends[@]} -eq 0 ]]; then
			selected_backends=("none")
		fi
		
	elif [[ "$requested_mode" == "none" ]]; then
		selected_backends=("none")
		
	else
		# User-specified: comma-separated list
		IFS=',' read -ra requested_backends <<< "$requested_mode"
		
		for backend in "${requested_backends[@]}"; do
			backend=$(echo "$backend" | xargs)  # trim whitespace
			
			if [[ " ${available_backends[*]} " =~ " $backend " ]]; then
				selected_backends+=("$backend")
			else
				warning "Requested GPU backend '$backend' not available"
			fi
		done
		
		if [[ ${#selected_backends[@]} -eq 0 ]]; then
			warning "No requested GPU backends available, building CPU-only"
			selected_backends=("none")
		fi
	fi
	
	# Set global variables
	GPU_MODE="${selected_backends[0]}"
	GPU_BACKENDS=$(IFS=','; echo "${selected_backends[*]}")
	
	# Export paths for selected backends
	if [[ " ${selected_backends[*]} " =~ " cuda " ]] && [[ -n "${CUDA_PATH:-}" ]]; then
		export CUDA_PATH
	fi
	
	if [[ " ${selected_backends[*]} " =~ " rocm " ]] && [[ -n "${ROCM_PATH:-}" ]]; then
		export ROCM_PATH
	fi
	
	msg "Selected GPU backends: $GPU_BACKENDS"
	return 0
}

###############################################################################
# PLATFORM MODULES
###############################################################################

# Module: Platform Detection
platform_module_detect() {
	local uname_s uname_m
	
	uname_s=$(uname -s)
	uname_m=$(uname -m)
	
	case "$uname_s" in
		Linux)
			# Detect Linux distribution
			if [[ -f /etc/os-release ]]; then
				local distro_id
				distro_id=$(grep "^ID=" /etc/os-release | cut -d= -f2 | tr -d '"' | tr '[:upper:]' '[:lower:]')
				
				case "$distro_id" in
					ubuntu|debian)
						PLATFORM="deb"
						;;
					rocky|rhel|centos|fedora)
						PLATFORM="rocky"
						;;
					*)
						# Try to detect based on package manager
						if has_cmd apt-get; then
							PLATFORM="deb"
						elif has_cmd dnf || has_cmd yum; then
							PLATFORM="rocky"
						else
							fatal "Unsupported Linux distribution: $distro_id"
						fi
						;;
				esac
			else
				# Fallback: use package manager
				if has_cmd apt-get; then
					PLATFORM="deb"
				elif has_cmd dnf || has_cmd yum; then
					PLATFORM="rocky"
				else
					fatal "Cannot detect Linux distribution"
				fi
			fi
			;;
		Darwin)
			PLATFORM="osx"
			;;
		*)
			fatal "Unsupported operating system: $uname_s"
			;;
	esac
	
	msg "Platform detected: $PLATFORM ($uname_s $uname_m)"
	return 0
}

###############################################################################
# BUILD CONFIGURATION MODULES
###############################################################################

# Module: Write GPU Configuration Header
config_module_gpu_header() {
	local config_file="${1:-include/neurondb_config.h}"
	
	msg_verbose "Writing GPU configuration to $config_file"
	
	cat >> "$config_file" <<EOF
/* GPU support flags - Generated by build.sh */
EOF
	
	# CUDA
	if [[ " ${GPU_BACKENDS} " =~ " cuda " ]] && [[ -n "${CUDA_PATH:-}" ]]; then
		cat >> "$config_file" <<EOF
#define NDB_GPU_CUDA 1
#define HAVE_CUDA 1
#define CUDA_PATH "${CUDA_PATH}"
EOF
		msg "CUDA support: Enabled"
	else
		cat >> "$config_file" <<EOF
/* #undef NDB_GPU_CUDA */
/* #undef HAVE_CUDA */
EOF
	fi
	
	# ROCm
	if [[ " ${GPU_BACKENDS} " =~ " rocm " ]] && [[ -n "${ROCM_PATH:-}" ]]; then
		cat >> "$config_file" <<EOF
#define NDB_GPU_HIP 1
#define ROCM_PATH "${ROCM_PATH}"
EOF
		msg "ROCm support: Enabled"
	else
		cat >> "$config_file" <<EOF
/* #undef NDB_GPU_HIP */
EOF
	fi
	
	# Metal
	if [[ " ${GPU_BACKENDS} " =~ " metal " ]]; then
		cat >> "$config_file" <<EOF
#define NDB_GPU_METAL 1
EOF
		msg "Metal support: Enabled"
	else
		cat >> "$config_file" <<EOF
/* #undef NDB_GPU_METAL */
EOF
	fi
}

# Module: Write Makefile.local with GPU configuration
config_module_makefile_local() {
	local makefile_local="${1:-Makefile.local}"
	
	msg_verbose "Writing build configuration to $makefile_local"
	
	cat > "$makefile_local" <<EOF
# Makefile.local - Generated by build.sh
# Generated: $(date)

PG_CONFIG ?= ${SELECTED_PG_CONFIG}
PG_MAJOR ?= ${PG_MAJOR_SELECTED:-18}
GPU_MODE ?= ${GPU_MODE:-none}
GPU_BACKENDS ?= ${GPU_BACKENDS:-none}
CUDA_PATH ?= ${CUDA_PATH:-}
ROCM_PATH ?= ${ROCM_PATH:-}
ONNX_RUNTIME_PATH ?= ${ONNX_RUNTIME_PATH:-/usr/local/onnxruntime}

# Build flags
V ?= 1
QUIET_ONNX ?= 1

# Avoid LTO crashes with some toolchains
CFLAGS += -O2 -fPIC -fno-lto
LDFLAGS += -fno-lto

.PHONY: compile
.DEFAULT_GOAL := compile
compile: all
EOF
	
	success "Build configuration written to $makefile_local"
}

